#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <getopt.h>
#include <pthread.h>
#include "types.h"
#include "const.h"
#include "util.h"

int arr[10];
bool fnd = false;
int found;
int max;
int min;
int xx;
int n = sizeof(arr);
int max_threads;
int c = 0;

// TODO: implement
int serial_binsearch(int arr[], int l, int r, int x)
{
    if (r >= l)
    {
        int mid = l + (r - l) / 2;

        if (arr[mid] == x)
            return mid;

        if (arr[mid] > x)
            return serial_binsearch(arr, l, mid - 1, x);

        return serial_binsearch(arr, mid + 1, r, x);
    }
    return -1;
}

// TODO: implement
void *parallel_binsearch(void *arg)
{
    c++;
    int c_parts = n / max_threads;
    min = (c - 1) * c_parts;
    max = c * c_parts;
    while (max >= min && !fnd)
    {
        int mid = min + (max - min) / 2;

        if (arr[mid] == xx)
        {
            found = arr[mid];
            fnd = true;
            break;
        }

        if (arr[mid] > xx)
        {
            max = mid - 1;
        }
        else
        {
            min = mid + 1;
        }
    }
    return NULL;
}

int main(int argc, char **argv)
{
    /* TODO: move this time measurement to right before the execution of each binsearch algorithms
     * in your experiment code. It now stands here just for demonstrating time measurement. */
    clock_t cbegin = clock();
    int max_threads = sysconf(_SC_NPROCESSORS_ONLN);
    pthread_t m_tid[max_threads];

    printf("[binsearch] Starting up...\n");

    /* Get the number of CPU cores available */
    printf("[binsearch] Number of cores available: '%ld'\n",
           sysconf(_SC_NPROCESSORS_ONLN));

    int size = -1, position = -1;
    char experiments[3] = "";
    int option = 0;
    /* TODO: parse arguments with getopt */
    while ((option = getopt(argc, argv, "T:E:P:")) != -1)
    {
        switch (option)
        {
        case 'T':

            strcpy(experiments, optarg);
            printf("[0]%s\n", optarg);
            continue;
        case 'E':

            size = atoi(optarg);
            continue;
        case 'P':

            position = atoi(optarg);
            continue;
        default:
            printf("Parameters wrong");
            exit(1);
        }
    }
    size = size * atoi(experiments) * position;
    /* TODO: start datagen here as a child process. */
    pid_t i = fork();
    if (i == 0)
    {
        if (execv("./datagen", argv) < 0)
        {
            printf("Doesnt works");
            exit(1);
        }
    }
    else if (i > 0)
    {
    }
    else
    {
        perror("fork failed");
        exit(3);
    }
    /* TODO: implement code for your experiments using data provided by datagen and your
     * serial and parallel versions of binsearch.
     * ocupar read del socket para el arreglo del binsearch
     */

    /* TODO: connect to datagen and ask for the necessary data in each experiment round.
     * Create a Unix domain socket with DSOCKET_PATH (see const.h).
     * Talk to datagen using the messages specified in the assignment description document.
     * Read the values generated by datagen from the socket and use them to run your
     * experiments
     * */

    struct sockaddr_un addr;

    int fd;

    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
    {
        perror("socket error");
        exit(-1);
    }
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, DSOCKET_PATH, sizeof(addr.sun_path));
    int re = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
    while (re == -1)
    {
        re = connect(fd, (struct sockaddr *)&addr, sizeof(addr));
    }
    char arr[20] = "BEGIN S";
    strcat(arr, experiments);
    printf("[1]%s\n", experiments);
    printf("[2]%s\n", arr);
    write(fd, arr, sizeof(arr));
    /*
    while ((rc = read(fd, buf, sizeof(buf))) > 0)
    {
        if (write(fd, buf, sizeof(buf)) != rc)
        {
            if (rc > 0)
            {
                fprintf(stderr, "partial write\n");
            }
            else
            {
                perror("write error");
                exit(-1);
            }
        }
    }
    fprintf(stderr, "hola\n");*/
    int ret;
    char buf1[1000];
    int counter_p = 0;
    int a = pow(10, atoi(experiments));
    while ((ret = read(fd, buf1, sizeof(buf1))) > 999)
    {
        char *help;
        long val = strtoul(buf1, &help, 10);
        printf("%i", ret);
        if (ret > 0)
        {
            printf("[binsearch]%li, %i, %d\n", val, counter_p, a);
            counter_p++;
        }
    }
    write(fd, DATAGEN_END_CMD, sizeof(DATAGEN_END_CMD));
    for (int i = 0; i < max_threads; i++)
        pthread_create(&m_tid[i], NULL, parallel_binsearch, (void *)NULL);

    for (int i = 0; i < max_threads; i++)
        pthread_detach(m_tid[i]);
    if (fnd)
    {
        printf("se encontro %d \n", found);
    }
    else
    {
        printf("no se encontro %d \n", xx);
    }
    //serial_binsearch();

    /* Probe time elapsed. */
    clock_t cend = clock();

    // Time elapsed in miliseconds.
    double time_elapsed = ((double)(cend - cbegin) / CLOCKS_PER_SEC) * 1000;

    printf("Time elapsed '%lf' [ms].\n", time_elapsed);

    exit(0);
}